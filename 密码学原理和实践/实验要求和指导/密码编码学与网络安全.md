# 密码编码学与网络安全

# 目录

[TOC]



# 第一部分 概览

## 第1章 计算机与网络安全概念

本书主要讨论两大领域：

1. 广泛使用的密码算法与协议
2. 大量依赖于密码技术的网络和Internet安全

**密码算法与协议**又可以分为4个主要领域：

1. 对称加密：加密任意大小的数据块或数据流的内容(包括消息、文件、加密密钥和口令)
2. 非对称加密 加密小数据块(如加密密钥或数字签名中使用的散列函数值)
3. 数据完整性算法 保护数据块的内容不被修改
4. 认证协议 基于密码算法设计的认证方案，用来认证实体的身份

**网络和Internet安全**领域涉及组织、防止、检测和纠正信息传出中出现的安全违规行为的措施，其内容相当广泛



### 1.1计算机安全的概念

对于一个自动化的信息系统，采取保护措施确保信息系统资源(包括硬件，软件，固件，信息/数据和通信)的完整性、可用性和保密性

> 定义来自NIST的《计算机安全手册》

- 保密性(Confidentiality)
  - 数据保密性 确保隐私或秘密信息不向非授权者泄露，也不被非授权者使用
  - 隐私性 确保个人能够控制或确定与其自身相关的哪些信息是可以被收集、保存的，这些信息可以由谁来公开以及向谁公开
- 完整性(Integrity)
  - 数据完整性 确保信息和程序只能以特定和授权的方式进行改变
  - 系统完整性 确保系统以一种正常方式来执行预定的功能，免于有意或无意的非授权操作

- 可用性(Availability)

系统能工作迅速，对授权用户不能拒绝服务

这三个概念组成了CIA三元组，其体现了数据、信息和计算服务的基本安全目标



一些额外的安全概念：

- 真实性(Authenticity)

一个实体是真实性的，可被验证的和可被信任的特性

> 对于传输信息来说，信息和信息来源是正确的

- 可追溯性(Accountability)

这时安全目标要求实体行为可以唯一追溯到实体，这一属性支持不可否认性，组织，故障隔离，入侵预测和预防，时候恢复，以及法律诉讼



### 1.2 OSI安全架构

OSI安全架构是提供安全的一种组织方法，这个框架是作为国际标准而开发的

OSI安全架构主要关注安全攻击、安全机制和安全服务，它们简短地定义如下：

**安全攻击**

任何危机信息系统安全的行为

**安全机制**

用来检测、组织攻击或从攻击状态恢复到正常状态的过程(或实现该过程的设备)

**安全服务**

加强数据处理系统和信息传输的安全性的一种处理过程或通信服务，目的在于利用一种或多种安全机制进行反攻击



### 1.3 安全攻击

X.800和RFC4949都将攻击划分为被动攻击和主动攻击

#### 1.3.1 被动攻击

被动攻击的特性是对传输进行窃听和监测

攻击者的目标是获得传输的信息，信息内容的泄露和流量分析都属于被动攻击

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%9B%BE1.2%20%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB.png)

信息内容的泄露很容易理解

**流量分析**

假设我们已经使用方法隐藏了消息内容或其他信息流量，攻击者即使截获了消息也无法从消息中获得信息

即使我们对消息进行了恰当的加密保护，攻击者仍能具有可能获得这些消息的一些模式。

> 攻击者可以确定通信主机的身份和位置，可以观察到传输消息的频率和长度，攻击者可以利用这些信息来判断通信的某些性质

#### 1.3.2 主动攻击

主动攻击包括对数据流进行修改或伪造数据流，分为四类：伪造、重放、消息修改和拒绝服务

**伪造**

某实体伪装成其他实体，伪装攻击通常还包含其他形式的主动攻击

> 例如：截获某认证信息，并在认证信息完成合法验证后进行重放，无权限的实体就可以通过冒充有权限的实体获得额外的权限

**重放**

攻击者未经授权地将解惑地信息再次发送

**消息修改**

未经授权地修改合法消息地一部分，或延迟消息地传送，改变消息的顺序

**拒绝服务**

组织或禁止对通信设施的正常使用或管理

> 拒绝服务的另一种形式是破坏整个网络，或是使网络失效，过载以降低其性能



主动攻击难以绝对预防，所以对于主动攻击，重点在于检测并从攻击造成的破坏或延迟中恢复过来



### 1.4 安全服务

**安全服务的定义**

在通信开放系统中，为系统或数据传输提供足够安全的协议层服务(X.800)

安全服务是一种由系统提供的对系统资源进行特殊保护的处理或通信服务，安全服务通过安全机制来实现安全策略(RFC4949)

**安全服务的分类**

X.800将这些服务分为5类共14个特定服务

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%A1%A81.2%20%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1.png)

#### 1.4.1 认证

认证服务用以保证通信的真实性

对于单条消息的情况，认证服务功能向接收方保证消息确实来自所声称的发送方

对于进行中的通信，会涉及发送方和接收方两个主体

在连接的初始化阶段，认证服务保证两个实体是可信的，也就是说，每个实体是他们所声称的实体。其次，认证服务必须保证该连接不受第三方干扰

> 第三方干扰是指，第三方伪装成两个合法实体中的一个进行非授权传输或接收

X.800定义了以下两个特殊的认证服务：

- **对等实体认证**

为连接中的对等实体提供身份确认

- **数据源认证**

为数据的来源提供确认，对数据的赋值和修改并不提供保护

#### 1.4.2 访问控制

在网络安全中，访问控制是限制和控制那些通过通信连接对主机与应用进行访问的一种能力

> 每个试图获得访问控制的实体必须被识别或认证后，才能获取相应的访问权限

#### 1.4.3 数据保密性

**防止传输的数据遭到被动攻击**

关于数据传输，其保护可以分成不同的层级，最广泛的服务是在一段时间内为两个用户间传输的所有用户数据提供保护

也可以定义一种较窄的保密性服务，可以是为单条消息或者对单挑消息内的某个特定的范围提供保护，与广泛的方法相比，这种细化用处要少，实现起来更复杂，成本更高



保密性的另一个方面是要**防止流量分析**

#### 1.4.4 数据完整性

数据完整性可应用于消息流、单条消息或消息的指定部分。最直接和最有用的方法是对整个数据流提供保护

用于处理消息流、而向连接的完整性服务保证收到的消息和发出的消息一致，保证消息未被复制、插入、修改、更改顺序或重放。该服务也涉及对数据的破坏。因此，**面向连接的完整性服务需要处理消息流的修改和拒绝服务两个问题**。另一方面，**无连接的完整性服务仅处理单条消息**，而不管大量的上下文信息，因此通常仅防止对消息的修改。

**完整性服务还可分为可恢复的服务和无恢复的服务**。因为完整性服务和主动攻击有关，我们更关心检测而非阻止攻击。如果检测到完整性遭破坏，那么服务可以简单地报告这种破坏，并通过软件的其他部分或人工干预来恢复被破坏的部分。也可使用一些机制来恢复数据完整性，通常，自动恢复机制是一种更有吸引力的选择。



#### 1.4.5 不可否认性

不可否认性防止发送方或接收方否认传输或接收过某条消息

#### 1.4.6 可用性服务

根据系统的性能说明，系统资源可被授权实体请求访问或使用



### 1.5 安全机制

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%A1%A81.3%20%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%20%E8%A1%A81.4%20%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1%E4%B8%8E%E6%9C%BA%E5%88%B6%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.png)

由上表可知，安全机制分为两类：一类在特定的协议层实现，如TCP或应用层协议。另一类不属于任何协议层或安全服务

可逆加密机制是一种单纯的加密算法，数据可以加密和解密

不可逆加密机制包括用于数字签名和消息认证应用中的散列算法与消息认证码



### 1.6 网络安全模型

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%9B%BE1.5%20%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.png)

需要保护传输信息，防止攻击者对信息机密性、真实性等进行攻击时，安全技术开始发挥作用

所有提供安全的技术都包含以下两部分：

- 对发送信息的安全变换 (如加密消息，基于消息内容，附加一段基于消息内容的编码，用于验证发送者身份)

- 被两个主体共享且不被攻击者知道的一些机密信息。如在传输之前用于加密信息，收到消息后用于解密消息的密钥

为了实现安全传输，可能需要有可信的第三方。例如，第三方负责将秘密信息分配给通信双方而对攻击者保密，或当通信双方关于信息传输的真实性发生争执时，由第三方来仲裁。

上述模型说明，设计安全服务应包含如下4个方面的内容:

1. 设计一个算法，它执行与安全相关的变换。该算法应是攻击者无法攻破的。
2. 产生算法所使用的秘密信息。
3. 设计分配和共享秘密信息的方法
4. 指明通信双方使用的协议，该协议利用安全算法和秘密信息实现安全服务。



另一种有害访问是在计算机系统中加入程序，利用系统的弱点来影响应用程序和实用功能程如编辑程序和编译程序。这种程序引起的威胁有两种程序:

1. **信息访问威胁** 以未授权用户的名义截获或修改数据
2. **服务威胁** 利用计算机中的服务缺陷禁止合法用户使用这些服务

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%9B%BE1.6%20%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.png)

对付有害访问所需的安全机制分为两大类。

第一类称为门卫功能，它包括基于口令的登录过程(该过程只允许授权用户的访问)和监控程序(负责检测和阻止蠕虫、病毒及其他类似的攻击)。

一旦非法用户或软件获得了访问权，那么由各种内部控制程序组成的第二道防线就会监视其活动、分析存储的信息，以便检测非法入侵者。



## 第2章 数论基础

### 2.1 整除性和带余除法

#### 2.1.1 整除

**整除的定义**

设a,b,m均为整数，若存在某个m似的a=mb成立，则称非零数b整除a，记作
$$
b|a
$$
同时，称b为a的一个因子

**整除的相关性质**

1. 若a|1，则a=±1
2. 若a|b，且b|a，则a=±b
3. 任何不等于0的数整除0
4. 若a|b且b|c，则a|c
5. 对于任意整数m,n，若b|g且b|h，则可得出b|(mg+nh)

#### 2.1.2 带余除法

对给定的任意一个正整数n和任意非负整数a,若用n除a，得到整数商q和整数余数r,则满足下列关系式：
$$
a=qn+r，~~~0\le r<n;q=\lfloor a|n \rfloor
$$


### 2.2 欧几里得算法

欧几里得算法是数论中一个最基本的技巧，用于简单地求出两个正整数的最大公因子

两个整数是互素的$\iff$ 这两个整数只有一个正整数公因子1

#### 2.2.1 最大公因子

整数a和b的最大公因子是能同时整除a和b的最大整数，记作gcd(a,b)

更正式的描述是：

1. c是a和b的因子
2. a、b的公因子都是c的一个因子

另一个等效定义
$$
gcd(a,b)=max[k,满足k|a,k|b]
$$
要求最大公因子必须是正数，所以
$$
gcd(a,b)=gcd(|a|,|b|)
$$
特别的
$$
gcd(a,0)=|a|
$$
**互素（互质）**

我们说整数a，b互质，当且仅当它们只有一个正整数公因子1



#### 2.2.2 求最大公因子

欧几里得算法可以简单地求出两个整数的最大公因子，算法的阐述可分为以下几点：

1. 假设我们需要求出整数a和b的最大公因子d；因为gcd(|a|,|b|)=gcd(a,b)，因此这里可以假定$a\ge b>0$
2. 使用带余除法，b除a可以表示为

$$
a=q_1b+r_1~~~0\le r_1<b
$$

3. 首先考虑到$r_1=0$的情况，因此可知b整除a，且a和b的公因子中不存在比b更大的数。所以d=gcd(a,b)=b
4. $r_1\ne 0$ 在这种情况下，可知一定有d|$r_1$，因为由因子的基本性质可知：存在d|a和d|b，那么一定有d|(a-$q_1b$)，即$d|r_1$
5. d|b和$d|r_1$,则，对于任意一个b和$r_1$的公因子c，有c|$(q_1b+r_1)=a$，因为c|a,c|b，所以$c\le d$，其中d是a和b的最大公因子，因此d=gcd($b,r_1$)

![](image/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95.png)

### 2.3 模运算

#### 2.3.1 模

如果a是一个整数，n是正整数，则我们定义a除以n所得的余数为a模n。整数n称为模数。所以带余除法可以写作
$$
a=\lfloor a/n \rfloor +(a~mod~n)
$$

#### 2.3.2 同余的性质

1. 若$n|(a-b)$，则$a\equiv b (mod~n)$
2. 若$a\equiv b (mod~n)$,则$b\equiv a(mod~n)$
3. 若$a\equiv b (mod~n)$，$b\equiv c (mod~n)$，则有$a\equiv c (mod~n)$



#### 2.3.3 模算术运算

模运算mod n，将所有整数映射到集合{0,1,...,(n-1)}中，我们可以在这个集合上进行算术运算，称为模算术

模算术有如下性质:
$$
(1)~[(a~mod~n)+(b~mod~n)]=(a+b)~mod~n\\
(2)~[(a~mod~n)-(b~mod~n)]=(a-b)~mod~n\\
(3)~[(a~mod~n)\times (b~mod~n)]=(a\times b)~mod~n\\
$$


#### 2.3.4 模运算的性质

定义比n小的非负整数集合为$Z_n$
$$
Z_n={0,1,...,(n-1)}
$$
这个集合称为剩余类集，或模n剩余类，Zn中的每一个整数都代表一个剩余类，我们可以将模n的剩余类表示为[0],[1],...,[n-1]

其中
$$
[r]=\{a:a是一个整数，a\equiv r(mod~n)\}
$$
在剩余类的所有整数中，我们通常使用最小非负整数来代表这个剩余类。寻找与k是模n同于的最小非负整数的过程，称为模n的k约化

**$Z_n$是有乘法单位元的交换环** 满足以下性质

![](image/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Zn%E4%B8%AD%E6%95%B4%E6%95%B0%E6%A8%A1%E8%BF%90%E7%AE%97%E7%9A%84%E6%80%A7%E8%B4%A8.png)



若a与n互素，则
$$
(a\times b)\equiv (a\times c)(mod~n),则b\equiv c(mod~n)
$$
对于任何一般的模数n，若a与n有任何公因子的话，用乘数a依次作用于0到n-1的所有整数将不会产生a的一个完整剩余类集

只有一个整数与n互素时，它才会在Zn中存在一个乘法逆元

#### 2.3.5 回顾欧几里得算法

欧几里得算法可以写成如下形式，对任意整数a,b满足$a\ge b \ge 0$
$$
gcd(a,b)=gcd(b,a~mod~b)
$$


#### 2.3.6 扩展的欧几里得算法

扩展的欧几里得算法不仅可以计算出最大公因子d，而且可以得到两个整数x和y，满足
$$
ax+by=d=gcd(a,b)
$$
x,y一定具有相反的正负号

对于两个给定的整数a和b，可以表示为ax+by的最小正整数等于gcd(a,b)

下面介绍如何通过扩展欧几里得算法得到(x,y,d)
$$
a=q_1b+r_1,r_1=ax_1+by_1\\
b=q_1r_1+r_2,r_2=ax_2+by_2\\
...\\
r{n-2}=q_{n}r_{n-}+r_n,r_{n}=ax_n+by_n\\
r_{n-1}=q_{n+1}r_n+0
$$
由上式有
$$
r_i=r_{i-2}-q_ir_{i-1}\\
x_i=x_{i-2}-q_ix_{i-1}\\
y_i=y_{i-2}-q_iy_{i-1}\\
$$
其中$r_{-1}=a,r_0=b$



### 2.4 素数

**素数**

整数p>1是素数，当且仅当它只有因子±1和±p

**算术基本定理**

任意整数a>1都可以唯一地因式分解为
$$
a=p_1^{\alpha_1}\times p_2^{\alpha_2}\times...\times p_t^{\alpha_t}
$$
$p_1,...,p_t$均是素数，且$p_1<p_2<...<p_t$,且所有$a_i$都是正整数

**正整数的另一种表述**

设P是所有素数的集合，任意的正整数a可唯一表示为
$$
a=\prod_{p\in P}p^{\alpha_p},a_p\ge 0
$$
在这种情况下，两数相乘即对应指数相加

从素因子角度看整除，意味着任意整数n形成的$p^n$只能被小于等于相同次幂的同一素数$p^j$整除

若a整除b，则对于任意的$p\in P$ 有
$$
a_p\le b_p
$$
若将整数表示为素数之积，则很容易确定两个正整数的最大公因子
$$
若k=gcd(a,b)，则k_p=min(a_p,b_p),其中p\in P
$$

### 2.5 费马定理和欧拉定理

费马定理和欧拉定理在公钥密码学中占有重要地位

#### 2.5.1 费马定理

通常指费马小定理

若p是素数，a是正整数且不能被p整除，则
$$
a^{p-1}\equiv 1(mod~p)
$$
另一种形式,若p是素数且a是任意正整数,则
$$
a^p\equiv a~mod~p
$$

> 注意，这里不要求a与p互素，而第一个式子要求a与p互素

#### 2.5.2 欧拉函数

欧拉函数$\phi(n)$,指小于n且与n互素的正整数个数,$\phi(1)=1$

显然，对于素数 $\phi(p)=p-1$

假设有两个素数p和q，$p\ne q$，那么对于n=pq，有
$$
\phi(n)=\phi(pq)=\phi(p)\times \phi(q)=(p-1)(q-1)
$$


#### 2.5.3 欧拉定理

对于任意互素的a和n，有
$$
a^{\phi(n)}=1(mod~n)
$$

另一种形式
$$
a^{\phi(n)+1}=a(mod~n)
$$

> 与费马定理类似，后一种形式不要求a和n互素 



### 2.6 素性检验

许多密码算法都需要随机选择一个或多个非常大的素数，我们必须能够确定一个给定的大数是否是素数，这是一个困难问题

本节介绍一种较好的常用算法，该算法产生的数不一定是素数，但几乎可以肯定是素数

#### 2.6.1 Miller-Rabin算法

**预备知识**

$n\ge3$的奇整数可以表示如下
$$
n-1=2^kq,~~k>0,q是奇数
$$
素数的两个性质：

1. 若p是素数，a是小于p的正整数，则$a^2~mod~p=1$当且仅当$a~mod~p=1或a~mod~p=-1=p-1$
2. 设p是大于2的素数，我们有p-1=$2^kq$,其中k>0,q为奇数，设a是整数且1<a<p-1,则下面两个条件之一成立:
   1. $a^q~mod~p=1$
   2. 整数$a^q,a^{2q},a^{4q},...,a^{2^{k-1}q}$中存在一个数，模p时与-1同余



由此可得，若n为素数，则剩余类数列($a^q,a^{2q},...,a^{2^kq}$)中，要么第一个数模n为1，要么数列中某个数模n为(n-1)

> 另外，如果条件满足，无法确定n是否是素数

我们可以利用上述性质做素性测试

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Miller-Robin%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C.png)

我们可以重复使用Miller-Rabin算法，如果选择t个不同的a，都能通过测试，那么在t足够大的情况下，我们能以很大把握说n是素数

> ASK算法是一个判定一个大数是否为素数的确定性算法，但执行速度较慢，未能代替古老的概率算法

#### 2.6.3 素数的分布

**素数定理**

n附近的素数分布情况为，平均每ln(n)个整数中有一个素数，因为所有的偶数一定不是素数，则我们找到一个素数钱，需要测试的整数个数为0.5xln(n)

> 上面所说的只是平均值，数轴上有些位置，素数非常密集，而有些位置，素数非常稀疏

### 2.7 中国剩余定理

某一范围内的整数可通过它的一组剩余类数来重构，这组剩余类数是对该整数使用一组两两互素的整数取模得到的

一种表示形式
$$
M=\prod_{i=1}^k m_i
$$
其中$m_i$是两两互素的，即对$1\le i,j\le k$有gcd$(m_i,m_j)=1$我们可以将$Z_M$中的任一整数对应一个k元组，该k元组的元组均在$Z_{m_i}$中，这种对应关系即为
$$
A\leftrightarrow (a_1,a_2,...,a_k)
$$
其中$A\in Z_M$，对$1\le i\le k,a_i\in Z_m$，且$a_i=A~mod~m_i$,中国剩余定理说明下列两个断言成立

1. 式中的映射是$Z_M$到笛卡尔积$Z_{m1}\times Z_{m2}\times...\times Z_{mk}$的一一对应
2. $Z_M$中元素上的运算可等价于对应的k元组上的运算，即在笛卡尔积的每个分量上独立地执行运算



### 2.8 离散对数

离散对数是包含Diffie-Hellman密钥交换算法和数字签名算法(DSA)在内许多公钥算法的基础

#### 2.8.1 模n的整数幂

根据欧拉定理，任何互素的a和n，有
$$
a^{\phi(n)}\equiv 1(mod~n)
$$
欧拉定理更一般的表达形式
$$
a^m\equiv 1(mod~n)
$$
若a与n互素，则至少有一个整数m满足上式，即m=$\phi(n)$，我们称使得上式成立地最小正幂m为下列之一

1. a(mod n)的阶
2. a所属的模n的指数
3. a所产生的周期长

$\phi(n)$是一个数所属的模n的可能得最高指数，如果一个数的阶为$\phi(n)$，则称之为n的**本原根**

若a是n的本原根，则其幂
$$
a,a^2,...,a^{\phi({n})-1}
$$
是各不相同的，且均与n互素

并非所有整数都有本原根，只有形如2,4,$p^\alpha$和$2p^\alpha$的整数才有本原根，p是任何奇素数，α是正整数，证明过程不简单，在此省略



#### 2.8.2 模算术对数

对于某素数p的本原根a，a的1到p-1的各次幂恰可产生1到(p-1)的每个整数，且仅一次。对于任何整数b，根据模算术的定义,b满足
$$
b\equiv r(mod~p),0\le r\le(p-1)
$$
对任意整数b和素数p的本原根a，有唯一的幂i使得
$$
b\equiv a^i(mod~ p),0\le i\le (p-1)
$$
该指数i称为以a为底(模p)的b的离散对数，记为$dlog_{a,p}(b)$



#### 2.8.3 离散对数的计算

考虑方程
$$
y=g^x~modp
$$
给定g,x和p，可直接计算出y，在最坏情况下需要执行x次乘法，而且存在计算y的有效算法

但是给定y,g,p，计算x一般非常困难(即求离散对数)

对大素数而言，该算法是不可行的

# 第二部分 对称密码

## 第3章 传统加密技术

对称加密，也叫做传统加密或单钥加密,是使用最为广泛的加密类型

**一些术语**

- 明文：原始的消息
- 密文：加密后的消息
- 加密：从明文到密文的转换过程
- 解密：从密文到明文的变换过程
- 密码编码学：研究各种加密方案的领域
- 密码体制或密码：基于密码编码学的加密方案
- 密码分析学：不知道任何加密细节的条件下解密消息的技术
- 密码学：密码编码学和密码分析学统称为密码学

### 3.1 对称密码模型

对称加密方案有五个基本成分：

- **明文** 原始可理解的消息或数据，是算法的输入
- **加密算法** 加密算法对明文进行各种代替和变换
- **密钥** 密钥也是加密算法的输入。密钥独立于明文和算法。算法根据所用的特定密钥而产生不同的输出。算法所用的确切代替和变换也依靠密钥
- **密文** 作为算法的输出，看起来完全随机而杂乱的消息，依赖于明文和密钥。对于给定的消息，不同的密钥产生不同的密文，密文看上去是随机的数据流，并且其意义是不可理解的
- **解密算法** 本质上是加密算法的逆运算。输入密文和密钥，输出原始明文

传统密码的安全使用要满足以下两个要求：

1. 加密算法是足够强的

> 即使敌手拥有一定数量的密文和产生这些密文的明文，他也不能破译密文或发现密钥

2. 发送者和接收者必须在某种安全的形式下获得密钥并且必须保证密钥安全

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%9B%BE3.1%20%E4%BC%A0%E7%BB%9F%E5%AF%86%E7%A0%81%E7%9A%84%E7%AE%80%E5%8C%96%E6%A8%A1%E5%9E%8B.png)

假设基于已知密文和已知加密/解密算法而破译消息是不实际的

在这个条件下，我们不需要算法保密，仅需要密钥保密

对称密码的这些特点使其能够广泛地应用，算法不需要保密这一事实使得制造商可以开发出低成本的芯片以实现数据加密算法

**采用对称密码，首要的安全问题是密钥的保密性**



![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%9B%BE3.2%20%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E7%9A%84%E6%A8%A1%E5%9E%8B.png)

发送方产生明文消息X=[X1,X2,...,XM],X的M个元素是某个字母表中的字母

传统上，字母表由26个大写字母组成，而现在，最常用的是二进制字母表{0,1}

加密时，先产生一个形如K=[K1,K2,...,KJ]的密钥

如果密钥是由信息的发送方产生的，那么他要通过某种安全信道发送到接收方，另一种说法是由第三方生成密钥后再安全地分发给发送方和接收方



加密算法根据输入信息X和密钥K生成密文Y=[Y1,Y2,...,YN]，即
$$
Y=E(K,X)
$$
拥有密钥K的预定接收者，可以进行一下变化获得明文
$$
X=D(K,Y)
$$


#### 3.1.1 密码编码学

密码编码学系统具有以下三个独立的特征：

1. **转换明文为密文的运算类型**

所有的加密算法都基于两个原理——代替和置换

代替是将明文中的每个元素映射成另一个元素；置换是将明文中的元素重新排列

上述运算的基本要求是不允许有信息的丢失，即所有运算是可逆的

大多数密码体制，也成为乘积密码系统，都使用了多层代替和替换

2. **所用的密钥数**

如果发送方和接收方都是用相同的密钥，这种密码就称为对称密码，单密钥密码、秘密钥密码或传统密码

如果收发双方使用不同的密钥，这种密码就称为非对称密码，双钥或公钥密码

3. **处理明文的方法**

分组密码每次处理输入的一组元素，相应地输出一组元素

流密码则是连续地处理输入元素，每次输出一个元素



#### 3.1.2 密码分析学和穷举攻击

攻击密码系统地典型目标是恢复使用的密钥而非仅仅恢复出单个密文对应的明文

攻击传统的密码体制有两种通用的方法：

- **密码分析学**

密码分析学攻击依赖于算法的性质、明文的一般特征或某些明密文对。这种形式的攻击企图利用算法的特征来推导出特定的明文或使用的密钥

- **穷举攻击**

攻击者对一条密文尝试所有可能的密钥知道把它转化为可读的有意义的明文



**密码分析学攻击**

基于密码分析者知道信息的多少，可以概括出密码攻击的几种类型

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/3.1%20%E5%AF%B9%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E7%9A%84%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B.png)

如果一个密码体制满足条件：无论有多少可使用的密文，都不足以唯一地确定密文所对应的明文，则称该密码体制是无条件安全的

除了一次一密，所有的加密算法都不是无条件安全的

加密算法的使用者应挑选尽量满足以下标准的算法：

- 破译密码的代价超出密文信息的价值
- 破译密码的时间超出密文信息的有效生命周期

加密体制满足上述两条标准种的任意一条，则它是计算上安全地



**穷举攻击**

尝试所有密钥直到有一个合法的密钥能够把密文还原成明文



### 3.2 代替技术

#### 3.2.1 Caesar密码

对于每个明文字母p，通过移位任意整数k，可以代替为密文字母C：
$$
C=E(k,p)=(p+k)~mod~(26)
$$

$$
p=D(k,C)=(C-k)~mod~(26)
$$



对Caesar密码的穷举攻击是很容易实现的，只要简单地测试所有25种可能得密钥，这取决于Caesar密码的三个特征：

1. 已知加密和解密算法
2. 需测试的密钥只有25个
3. 明文所用的语言是已知的，且其意义易于识别



#### 3.2.2 单表代替密码

通过允许任意代替，密钥空间将会急剧增大

一般地，具有n个元素的集合由n!个置换，这种方法被称为单表代替

通过把字母使用的相对频率统计出来，与英文字母的使用频率分布进行比较，根据统计规律，我们可以推测密文字母与明文字母的对应关系

统计双字母组合的频率也是一个很有效的工具

单表代替密码由于带有一些原始字母使用频率的统计学特征，很容易被攻破



#### 3.2.3 Playfair密码

Playfair密码是最著名的多字母代替密码，把明文中的双字母音节作为一个单元并将其转换为密文的"双字母音节"



**基于密钥词构造的字母矩阵**

Playfair密码的第一步是根据密钥词构造一个5x5的字母矩阵，构造方法如下：

先将密钥词(去掉重复字母)从左至右，从上到下填在矩阵格子中，再将剩余的字母按字母表的顺序从左至右，从上到下填在剩余的格子里,字母I/J当作一个字母



**加密过程**

明文按照如下规则，一次性加密两个字母

1. 如果该字母对的两个字母是相同的，那么在它们之间加一个填充字母
2. 落在矩阵同一行的明文字母对中的字母由其右边的字母来代替，每行最右边的一个字母就用该行最左边的字母代替
3. 落在矩阵同一列的明文字母对中的字母由其下面的字母来代替，每列中最下面的字母就用该列最上面的第一个字母来代替

4. 其他的魅族明文字母对中的字母按如下方式代替，该字母所在行为密文所在行，该字母所在列为密文所在列



相比于单表代替密码，Playfair密码要更优秀一些，26个字母由676个字母对，因此识别出单个字母对要困难得多，并且单个字母的相对频率比字母对的相对频率变化的幅度大，在统计规律上要好，利用频率分析字母对就更困难



Playfair密码仍然透露了大量的信息给密码分析者

#### 3.2.4 Hill密码

**Hill算法**

Hill加密算法将m个连续的明文字母替换成m个密文字母，该替换是由m个线性等式决定的，在等式里，每个字母被指定为一个数值(a=0,b=1,...,z=25)

当m=3时， 系统可以描述为
$$
c_1=(k_{11}p_1+k_{12}p_2+k_{13}P_3)~mod~26\\
c_2=(k_{21}p_1+k_{22}p_2+k_{23}P_3)~mod~26\\
c_3=(k_{31}p_1+k_{32}p_2+k_{33}P_3)~mod~26\\
$$
用行向量和矩阵表示如下
$$
(c_!,c_2,c_3)=(p_1,p_2,p_3) \begin{pmatrix}
k_{11} & k_{12} & k_{13} \\
k_{21} & k_{22} & k_{23} \\
k_{31} & k_{32} & k_{33}
\end{pmatrix} ~mod~26
$$
或
$$
\mathbf C=\mathbf P \mathbf K ~mod~26
$$


**Hill密码系统**

使用一般术语，Hill密码系统可表示如下:
$$
C=E(\mathbf K,\mathbf P)=\mathbf P \mathbf K~mod~26
$$

$$
\mathbf P=D(\mathbf K,\mathbf C)=\mathbf C \mathbf K^{-1}~mod~26=PKK^{-1}=P
$$



**Hill密码分析**

Hill密码完全隐蔽了单字母频率特性，Hill使用的矩阵越大，所隐藏的消息就越多

Hill密码足以抗惟密文攻击，但是它容易被已知明文攻击破解



#### 3.2.5 多表代替加密

对简单单标代替的改进方法是在明文消息中采用不同的单表代替，这种方式一般称之为多表代替密码，所有这些方法都有以下共同特征

1. 采用相关的单标代替规则集
2. 密钥决定给定变换的具体规则

##### Vigenere 密码

维吉尼亚密码是多表代替密码中最著名且最简单的密码，它的代替规则集由26个Caesar密码的代替表组成，其中每一个代替表是对明文字母表移位0~25次后得到的代替单表。每一个密码由一个密钥字母来表示，这个密钥字母用来代替明文字母a，故移位d次的Caesar密码由密钥值d来代表

假设明文序列为$P=p_0,p_1,...,p_{n-1}$，密钥由序列$K=k_0,k_1,...,k_{m-1}$构成，其中m<n，密码序列$C=C_0,C_1,...,C_{n-1}$计算如下
$$
C=C_0,C_1,...,C_{n-1}=E(K,P)=E[(k_0,k_1,...,k_{m-1},p_0,p_1,...,p_{n-1})]\\
=(p_0+k_0)~mod~26 (p_1+k_1)~mod~26,...,(p_{m-1}+k_{m-1})~mod~26,\\
(p_m+k_0)~mod~26,(p_{m+1}+k_1)~mod~26,...,(p_{2m-1}+k_{m-1})~mod~26,...
$$
加密过程的一般方程是
$$
C_i=(p_i+k_{i~mod~m})~mod~26
$$
解密方程
$$
p_i=(C_i-k_{i~mod~m})~mod~26
$$
**密码强度分析**

该密码使每个明文字母对应多个密文字母，且每个密文字母都使用唯一的密钥字母，屏蔽了字母出现的频率信息被屏蔽了，不过并非所有的明文结构信息都被隐蔽了



##### Vernam密码

该体制可简明表述为
$$
c_i=p_i \oplus k_i
$$
密文通过对明文和密钥的逐位异或形成，根据异或运算的特性，解密过程为
$$
p_i=c_i\oplus k_i
$$
事实上该体制使用的是周期很大的循环密钥

#### 3.2.6 一次一密

使用与消息一样长的且无重复的随机密钥来加密消息，且密钥只对一个消息进行加密，之后弃之不用

每一条新的消息都需要一个与其等长的新密钥

**安全性分析**

一次一密产生的随机输出与明文没有任何统计关系，密文不包含明文的任何消息，所以无法攻破

一次一密的安全性完全取决于密钥的随机性，如果构成密钥的字符流是真正随机的，那么构成密文的字符流也是真正随机的。分析者没有任何攻击密文的模式和规则可用

**两个基本难点**

1. 产生大规模随机密钥有实际困难
2. 密钥的分配和保护困难

因为上面这些困难，一次一密很少使用，主要用于安全性要求很高的低带宽信道

一次一密是唯一的具有完善保密的密码体制

### 3.3 置换技术

另一种加密方法，是对明文进行置换，称为置换密码



**栅栏密码**

按对角线顺序写出明文，而按行顺序读出作为密文

**一种更复杂的方案**

 将消息一行一行地写成矩形块，然后按列读出，但是把列的次序打乱，列的次序就是算法的密钥



单纯的置换密码因为有着与明文相同的字母频率特征而易被识别



多次置换密码相对来说更加安全，但复杂的置换是不容易重构的



### 3.4 轮转机

**基本原理**

轮转机包括一组相互独立的旋转圆筒，电脉冲可以通过它

每个圆筒有26个输入引脚和26个输出引脚

内部连线使每一个输入仅同唯一一个输出连接

**单筒系统**

只有一个圆筒的轮转机，每次按下一个输入键，圆筒就旋转一个位置，内部连线相应改变，经过26个明文字母后，圆筒回到初始位置，我们可以得到一个周期为26的多表代替面膜

**多筒系统**

每按依次输入键，第一个圆筒就旋转一个引脚的位置，第一个圆筒旋转完一圈后，第二个圆筒就转一个引脚的位置，以此类推

一个三筒系统，重复使用26x26x26=17576个不同的替换字母表

一个五筒轮转机相当于密钥长度为118811376的维吉尼亚密码

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%BD%AE%E8%BD%AC%E6%9C%BA.png)



### 3.5 隐写术

隐写术并不是加密，它是用来隐藏信息的存在

一些技术:

- 字符标记 选择一些印刷字母或打字机打出的文本，用铅笔在其上书写一遍，这些标记需要做得在一般场合下辨认不出，除非将纸张按某个角度对着亮光看
- 不可见墨水 有些物质用来书写后不留下可见痕迹，除非加热或加之以某种化学物质。
- 针刺 在某些字母上刺上小的针孔，这一般是分辨不出来的，除非对着光线。
- 打字机的色带矫正 用黑色的色带在行之间打印。用这种色带打印后的东西只在强光下可见。

**缺点**

它需要许多额外的付出来隐藏相对较少的信息。



**优点**

可以应用于如下的情况:通信双方宁愿内容丢失，也不愿他们进行秘密通信的事实被人发现。加密标识信息也是重要和秘密的，通过它可以找出想进行消息隐藏的发送方或接收方。



## 第4章 分组密码和数据加密标准

#### 4.1 传统分组密码结构

现在使用的大多数对称分组加密算法都是基于Feistel分组密码结构



#### 4.1.1 流密码与分组密码

**流密码**

流密码每次加密数据流的一位或一个字节

古典流密码的例子有密钥自动产生的Vigenere密码和Vernam密码，理想情况下，可以使用一次一密的Vernam密码，其中密钥流(ki)和明文位流(pi)一样长

密钥流必须提前以某种独立、安全的信道提供给双方，如果待传递的数据流量很大，就带来了一个不可逾越的障碍

在实际应用中，位流必须以算法程序的方式实现，从而双方都可以生产具有密码学意义的位流

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E6%AF%94%E7%89%B9%E6%B5%81%E5%8F%91%E7%94%9F%E5%99%A8%E7%9A%84%E6%B5%81%E5%AF%86%E7%A0%81.png)

位流发生器是一个由密钥控制的算法，它必须产生在密码学意义上是强壮的位流，两个用户只需要共享生成密钥，就可以各自产生密钥流



**分组密码**

将一个明文分组作为整体加密并且通常得到的是与明文等长的密文分组

分组大小通常为64位或128位

同流密码一样，两用户共享一个对称加密密钥

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81.png)

#### 4.1.2 Feistel密码结构的设计动机

**可逆变换**

分组密码作用在n位明文分组上，产生n位密文分组，共有$2^n$个不同的明文分组，且由于加密是可逆的，每一个明文分组将唯一地对应一个密文分组，这样的变换称为可逆变换，或非奇异变换



**理想分组密码**

允许生成最大数量的加密映射来映射明文分组

> **对于任意一个n bit的明文，都有一个唯一的n bit密文与之对应**



**理想分组密码应用的困难**

1. 对于小分组，密码系统等价于传统代替密码，容易被明文的统计分析方法攻击

2. 采用大规模分组的任意可逆代替密码(即理想分组密码)是不可行的，对于这样的密码，映射本身就是密钥

对于n位的代替分组密码，密钥规模是$n\times 2^n$，一个64位的分组密码，若分组有抗统计攻击的理想长度，其密钥大小约是$10^{21}$位



由于这些问题，Feistel指出我们所需的是对理想分组密码体制(分组长度n较大)的一种近似体制



#### 4.1.3 Feistel密码

Feistel建议使用乘积密码的概念来逼近理想分组密码

**乘积密码**

使用两个或两个以上的基本密码，所得结果的密码强度将强于所有单个密码的强度，这种方式的本质是开发一个分组密码，密钥长度k位，分组长度n位，采用$2^k$个变换，而不是理想分组密码的$2^n!$个可用变换



Feistel建议使用这样的密码：该种密码交替地使用代替和置换

- 代替：每个明文元素或元素组被唯一地替换为相应的密文元素或元素组
- 置换：明文元素的序列被替换为该序列的一个置换

> 事实上，这就是Claude Shannon提出的交替使用混淆和扩散的乘积密码的实际应用



**混淆与扩散**

扩散：明文的统计特征消散在密文中，这可以通过让每个明文数字尽可能多地影响多个密文数字获得

一个扩散的例子：使用下面的方法加密一段消息
$$
y_n=(\sum_{i=1}^k m_{n+i})~mod~26
$$
或者在二进制分组密码中，对明文进行置换后再用某个函数作用，重复多次就可以获得比较好的扩散效果



混淆：尽可能使密文和加密密钥间的统计关系



**Feistel密码结构**

加密算法的输入是2w位的明文分组和密钥K。明文分组被分为等长的两部分:$LE_0和RE_0$

这两半数据经过n轮迭代后组合成密文组合

第i轮迭代的输入$LE_{i-1}和RE_{i-1}$来自于上轮迭代的输出

而输入的子密钥$K_i$是由整个密钥K推导出的

每轮迭代都有相同的结构，代替作用在数据的左半部分。通常用轮函数F作用于数据的右半部分后，与左半部分数据进行异或来完成

每轮迭代的轮函数是相同的，但是输入的子密钥$K_i$不同

代替之后，交换数据的左右两半完成置换

这种结构是Shannon提出的代替置换网络的一种特别形式

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Feistel%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png)

Feistel结构的具体实现依赖于以下参数和特征：

- **分组长度** 分组长度越长意味着安全性越高，但是会降低加、解密速度，这种安全性的增加来自更好的扩散性，传统上，分组长度为64位比较合理，高级加密标准使用的是128位的分组长度

- **密钥长度** 密钥较长意味着安全性较高，但会降低加解密速度，这种安全性的增加来自于更好的抗穷尽攻击能力和更好的混淆性， 一般认为密钥长度位64位还不够，通常使用128位密钥
- **迭代轮数** Feistel密码的本质在于单轮不能提供足够的安全性而多轮加密可取得很高的安全性
- **子密钥生成算法** 子密钥产生越复杂，密码分析就越困难
- **轮函数** 轮函数越复杂，抗攻击能力就越强

其他两方面的考虑：

- **快速软件加解密** 加密算法被嵌入应用程序中，避免硬件实现的麻烦
- **简化分析难度** 有些时候，将算法设计的容易分析也有它的好处，比如分析其脆弱性，从而开发出更强的算法



**Feistel解密算法**

如上图，将密文作为算法的输入，逆序使用子密钥$K_i$



### 4.2 数据加密标准

DES 数据加密标准在2001年高级加密标准(AES)提出前，一直是使用最广泛的加密方案

DES使用64位分组长度和56位密钥长度，将64位输入经过一系列变换得到64位的输出。解密则使用了相同的步骤和密钥

该算法本身指的是数据加密算法(DEA)



#### 4.2.1 DES加密

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0.png)

对于任意加密方案，总共由两个输入：明文和密钥

DES的明文长度为64位，密钥长度为56位



**明文处理**

明文处理经过三个阶段:

1. 64位明文经过初始置换IP而被重新排列
2. 经过16轮相同函数的作用，每轮作用都有置换和代替。最后一轮迭代的输出有64位，它是输入明文和密钥的函数。其左半部分和右半部分互换产生预输出
3. 预输出再被与初始置换IP互逆的置换$IP^{-1}$作用产生64位的密文

**子密钥生成**

1. 密钥经过一个置换
2. 密钥经过循环左移和一个置换，分别得到各轮的子密钥$K_i$用于各轮的迭代



#### 4.2.2 DES解密

Feistel密码的解密算法和加密算法是相同的，只是子密钥的使用次序相反，此外，初始置换和最终置换是相反的



### 4.3 DES举例

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DES%E4%B8%BE%E4%BE%8B1.png)

#### 4.3.1 结果

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DES%E4%BE%8B%E5%AD%90%E7%BB%93%E6%9E%9C.png)

#### 4.3.2 雪崩效应

明文或密钥的某一位发生改变，将会导致密文的很多位的变化，这被称为雪崩效应,如果相应的该白你很小，可能会给分析者提供缩小搜索密钥或明文空间的渠道



### 4.4 DES的强度

#### 4.4.1 56位密钥的使用

56位的密钥共有$2^{56}$种可能，这个数字大约为$7.2 \times 10^{16}$，穷举攻击明显是不太实际的。一台每毫秒执行一次DES加密的计算机需要用1000年才能破解出密文

然而这一假设过于保守

今天的超级计算机应该可以在一个小时内找到密钥

增大密钥大小是防止使用简单蛮力攻击的有效方法

#### 4.4.2 DES算法的性质

关系DES算法性质的问题，主要集中在每轮迭代所使用的8个代替表(即S盒)上

因为这些S盒的设计标准，实际上包括整个算法的设计都是不公开的

这使得人们怀疑若是密码分析者直到S盒的构造方法，就可能知道S盒的弱点，进而攻击DES

多年来人们确实发现了S盒的许多规律和一些缺点，但是仍然没有人发现S盒存在致命的弱点



#### 4.4.3 计时攻击

计时攻击是通过观察算法的一个既定实现对多种密文解密的所需时间，来获得关于密钥或明文的信息

计时攻击所利用的事实是加密或解密算法对于不同的输入所花的时间有着细微的差别

> DES似乎能够很好地抵抗计时攻击，但是也给出了一些可能得研究建议
>
> 到目前为止，计时攻击还不可能成功地攻击DES,更不能攻击更强的对称密码，如3DES和AES



### 4.5 分组密码的设计原理

Feistel密码的强度来自于三个方面：迭代轮数，函数F和密钥使用算法

#### 4.5.1 迭代轮数

迭代轮数越多，密码分析就越困难，即使是F相对较弱也是这样的

迭代轮数的选择标准：使密码分析的难度大于穷举攻击的难度

> 这个标准使得判断算法强度和比较算法优劣变得容易
>
> 如果在密码分析方面没有突破，任何**满足这个标准**的算法强度**仅需要从密钥长度判断**



#### 4.5.2 函数F的设计

函数F是Feistel密码的核心，为其注入了混淆的成分

F的明显标准是非线性

其他几个标准：

- 算法有较好的雪崩效应

> 更严格的定义：严格雪崩效应准则SAC(Strict Avalanche Criterion)
>
> 对于任何的i和j，它要求若S盒的输入的任意一位i发生变化，输出的任意一位j发生变化的可能性为1/2
>
> SAC是对S盒而言的，但是作为一个标准，它同样可以适用于整个F函数



#### 4.5.3 密钥扩展算法

对于任何Feistel分组密码，密钥被用来为每轮迭代产生一个子密钥

一般来说，子密钥的选择应该加大推导子密钥及密钥种子的难度



## 第5章 有限域

### 5.1 群

#### 5.1.1 群

群G，有时记作{G,·}，是定义了一个二元运算的集合，这个二元运算可表示为·,
G中每一个序偶(a,b)通过运算生成G中的元素(a·b)，且满足下面公理:

1. 封闭性
2. 结合律
3. 单位元
4. 逆元

如果一个群的元素是有限的，我们称该群为有限群

群中元素的个数，称为群的阶

否则，称群为无限群

#### 5.1.2 交换群

一个群，如果还满足交换律，则称为交换群



#### 5.1.3 循环群

在群中定义求幂运算为重复运用群中的运算，定义$a^0=e$为单位元，且$a^{-n}=(a^{-1})^n$($a^{-1}$是a在群中的逆元)

如果群中的每一个元素都是一个固定元素a的幂$a^k$，则称G为循环群

我们认为元素a生成了群G，或者说a是群G的生成元

循环群总是交换群，他可能是有限群或无限群



### 5.2 环

环R，有时记作{R,+,x},是一个有两个二元运算的集合，这两个二元运算分别称为加法和乘法，且对于R中的任意元素a,b,c满足以下公理：

1. R关于加法是一个交换群，对于这种情况下的加法群，我们用0表示其单位元，-a表示a的逆元
2. 乘法满足封闭性
3. 乘法满足结合律
4. 分配律 对于R中的任意元素a、b、c，满足

$$
a(b+c)=ab+ac\\
(a+b)c=ac+bc
$$

如果环还满足下面条件，则被称为是交换环

1. 乘法满足交换律

整环是满足以下公理的交换环：

1. 乘法单位元
2. 无零因子



### 5.3 域

域F，有时记为{F,+,x},是有两个二元运算的集合，这两个二元运算分别称为加法和乘法，且对于F中的任意元素a、b、c满足以下公理：

1. F是一个整环
2. **乘法逆元** 对于F中的任意元素a(除0以外)，F中都存在一个元素$a^{-1}$使得a$a^{-1}$=$a^{-1}a$=1成立

本质上来说，域是一个集合，我们可以在其上进行加法、减法、乘法和出发而不脱离该集合。除法又按以下规则来定义：$a/b$=a($b^{-1}$)



可代替的描述:

域{F,+,x}是一个集合，定义两个二元运算--加法和乘法，满足下面两个条件

1. F对加法组成一个交换群
2. 除去零，F对乘法也组成一个交换群

3. 分配律成立

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BE%A4%E3%80%81%E7%8E%AF%E5%92%8C%E5%9F%9F%E7%9A%84%E6%80%A7%E8%B4%A8.png)

### 5.4 有限域 GF(p)

有限域的阶(元素的个数)必须是一个素数的幂$p^n$，n为正整数。阶为$p^n$的有限域一般记为GF($p^n$),GF代表Galois域



#### 5.4.1 阶为p的有限域

给定一个素数p，元素个数为p的有限域GF(p)被定义为整数{0,1,...,p-1}的集合$Z_p$，其运算为模p的算术运算



#### 5.4.2 在GF(p)中求乘法逆元

对于任意$a\in GF(p)$,a与G互素，我们可以通过扩展欧几里得算法计算a的乘法逆元



#### 5.4.3 小结

在本节里我们展示了如何造阶为p的有限域，其中p为素数。特别地，我们用以下性质定义有限域GF(p)

1. GF(p)由p个元素构成
2. 在该集合中定义了二元运算+和x。加减乘除可以在集合内实现，除0以外，集合内的其他元素都有乘法逆

GF(p)的元素是集合{0,1,...,p-1}中的元素，其算术运算是模p的加法和乘法



### 5.5 多项式运算

#### 5.5.1 普通多项式运算

一个n次多项式(n$\ge$0)的表达形式如下
$$
f(x)=\sum_{i=0}^n a_ix^i
$$
其中，这个$a_i$是某个指定数集S中的元素，该数集称为系数集，且$a_n \ne 0$

我们称f(x)是定义在系数集S上的多项式

0次多项式常称为常数多项式，仅仅是系数集里的一个元素，如果$a_n=1$，那么对应的n次多项式被称为首1多项式



**多项式运算**

包含加法、减法和乘法

这些运算是把变量x当成集合S中的一个元素来定义的，除法也以类似方式定义，但这是要求S是域

> 包括实数域、有理数域和素数域$Z_p$
>
> 整数集不是域，也不支持多项式除法运算

加法、减法的运算规则是把相应的系数相加减

若
$$
f(x)=\sum_{i=0}^n a_ix^i\\
g(x)=\sum_{i=0}^m b_ix^i\\
n\ge m 
$$
加法运算
$$
f(x)+g(x)=\sum_{i=0}^m(a_i+b_i)x^i+\sum_{m+1}^na_ix^i
$$
乘法运算定义为
$$
f(x)\times g(x)= \sum_{i=0}^{m+n}c_ix^i
$$
其中,$c_k=a_0b_k+a_1b_{k-1}+...+a_kb_0$



#### 5.5.2 系数在$Z_p$中的多项式运算

**域F上的多项式**

如果一个多项式，其系数是域F的元素，则称其为域F上的多项式

这样的多项式集合是一个环，称为多项式环



在非域系数集上进行多项式除法，除法运算并不总是有定义的



即使系数集是一个域，多项式除法也不一定是整除

给定n次多项式f(x)和m次多项式g(x)($m\le n$)，如果使用g(x)除f(x)，可以得到一个商q(x)和一个余数r(x),满足如下关系式:
$$
f(x)=q(x)g(x)+r(x)
$$
各多项式的次数为
$$
Degreef(x)=n\\
Degreeg(x)=m\\
Degreeq(x)=n-m\\
Degreer(x)\le m-1\\
$$
如果允许余数，我们说域上多项式除法是可以的

可以将余式r(x)写作f(x)modg(x)
$$
r(x)=f(x)~mod~g(x)
$$
如果r(x)=0，则称g(x)整除f(x),记作g(x)|f(x)



对我们而言，GF(2)上的多项式是最有意义的，因为在GF(2)中，加法等价于异或(XOR)，乘法等价于逻辑与(AND)



域F上的多项式f(x)被称为**不可约**的(既约的)当且仅当f(x)不能表示为两个多项式的积(两个多项式都在F上，次数都低于f(x)的次数)

一个不可约多项式也被称为**素多项式**



#### 5.5.3 求最大公因式

**最大公因式**

若c(x)是a(x)和b(x)的最大公因式，则

1. c(x)能同时整除a(x)和b(x)
2. a(x)和b(x)的任何因式都是c(x)的因式

记作gcd[a(x),b(x)]

可以改写欧几里得算法求得两个多项式的最大公因式
$$
gcd[a(x),b(x)]=gcd[b(x),a(x)~mod~b(x)]
$$


### 5.6 有限域GF($2^n$)

#### 5.6.1 动机

所有的加密算法，包括对称密钥和公开密钥算法，都涉及整数集上的运算

为了方便实用和提高效率，我们希望这个整数集中的数与给定的二进制位数所能表达的信息一一对应，不出现浪费，也就是说，我们希望这个整数集的范围从0到$2^n-1$，这样正好对应一个n位的字



我们既要使用所有的运算，又要使用n个二进制位所能表示的全部整数，那么以$2^n$为模的运算是不行的

> 因为当n>1时，以$2^n$为模的整数集不是一个域

即使加密算法只使用加法或者乘法，而不使用除法，以$Z_{2^n}$为模的整数集仍然存在问题

> 这样的算法将整数集不均匀地映射到自身

总之，我们需要寻找一个包含$2^n$个元素的集合，其上定义了加法和乘法使之称为一个域，我们给集合的每一个元素赋值为0到$2^n-1$之间的唯一整数



#### 5.6.2 多项式模运算

设集合S上由域$Z_p$上次数小于等于n-1的所有多项式组成，每一个多项式具有如下形式:
$$
f(x)=a_{n-1}x^{n-1}+a_{n-2}x^{n-2}+...+a_1x+a_0=\sum_{i=0}^{n-1}a_ix^i
$$
其中，$a_i$在{0,1,...,n-1}上取值，S中共有$p^n$个不同的多项式

如果定义了合适的运算，那么每一个这样的集合S都是一个有限域。定义由如下几条组成：

1. 该运算遵循代数基本规则中的普通多项式运算规则，且有如下两条限制
2. 系数运算以p为模，及遵循有限域$Z_p$上的运算规则
3. 如果乘法运算的结果是次数大于n-1的多项式，那么必须将其除以某个次数为n的既约多项式m(x)并取余式。对于多项式f(x)，这个余数可以表示为$r(x)=f(x)~mod~m(x)$

$$
例如：~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\\f(x)=x^6+x^4+x^2+x+1
\\g(x)=x^7+x+1\\
m(x)=x^8+x^4+x^3+x+1\\
f(x)\times g(x)~mod ~ m(x)=x^7+x^6+1
$$



**剩余类集合**

设m(x)为n次多项式，则模m(x)剩余类集合由$p^n$个元素，其中每个元素都可以表示称一个m次多项式(m<n)



我们可以证明，以n次既约多项式m(x)为模的所有多项式组合的集合可以形成一个有限域

且所有具有相同阶的有限域都是同构的



#### 5.6.3 求乘法逆元

正如Euclid算法可以用于求两个多项式的最大公因式，扩展Euclid算法可以用于求一个多项式的乘法逆元

给定两个多项式a(x)和b(x)，其中a(x)的次数大于b(x)的次数，我们希望解如下方程获得v(x),w(x)以及d(x)，其中d(x)=gcd[a(x),b(x)]
$$
a(x)v(x)+b(x)w(x)=d(x)
$$
如果d(x)=1,则w(x)是b(x)模a(x)的乘法逆，计算过程如下



![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Euclid.png)



####  5.6.4 计算上的考虑

GF($2^n$)中的多项式
$$
f(x)=\sum_{i=0}^{n-1}a_ix^i
$$
可以由它的n个二进制系数($a_{n-1},a_{n-2},...,a_2,a_1,a_0$)来表示



**加法**

多项式加法是将相应的系数相加，等价于系数按位异或运算



**乘法**

在$GF(2^n)$上对于n次多项式p(x)，有$x^n~mod~p(x)=p(x)-x^n$

计算
$$
x\times f(x)
$$
可以通过左移一位，再按条件位异或p(x)来实现

乘以x的更高次幂可以通过重复使用上面这个操作来完成



#### 5.6.5 使用生成元

定义有限域GF($2^n$)的另一种等价方式有时更方便

**两个定义**

阶位q的有限域F的生成元是一个元素，记为g，该元素的前q-1个幂构成了F的所有非零元素

有多项式f(x)定义的域F，如果F内的一个元素b满足f(b)=0,则称b为多项式f(x)的根

可以证明：一个不可约多项式的根g是这个不可约多项式定义的有限域的生成元



以不可约多项式$x^3+x+1$定义的有限域GF($2^3$)为例，设生成元为g

则有$g^3=-g-1=g+1$

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%85%83%E7%9A%84%E6%A8%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%BF%90%E7%AE%97.png)



## 第6章 高级加密标准

### 6.1 有限域算术

AES中的所有运算都是在8位的字节上进行的。特别地，加减乘除算术都是在有限域GF($2^8$)上进行的，其中不可约多项式为
$$
m(x)=x^8+x^4+x^3+x+1
$$

### 6.2 AES的结构

#### 6.2.1 总体结构

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B.png)

明文分组的长度为128位，16字节

密钥长度为16字节，24字节或32字节

根据密钥长度，算法被称为AES-128，AES-192,AES-256



加密和解密算法的输入是一个128位的分组

在FIPS PUB 197中，该分组被描述为4x4的字节方阵。这个分组被复制到state数组，并在加密或解密的各个阶段被修改

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)

同样地，密钥也被描述为字节的方阵，这个密钥接着被扩展为密钥字阵列

每个字是4字节，128位密钥最终扩展为44字的序列

> 矩阵中的字节是按列进行排序的



密码由N轮组成，其中轮数依赖于密钥长度，密钥长度为16/24/32字节，对应10/12/14轮

前N-1轮由4个不同的变换组成：字节代替，行位移，列混淆和轮密钥加

最后一轮仅包含三个变换，而在第一轮前面由一个起始的单变换(轮密钥加)，可以看作第0轮

每一个变换输入一个或多个4x4矩阵，并输出一个4x4矩阵

密钥扩展函数产生N+1轮密钥，它们是互不相同的4x4矩阵，每一个轮密钥作为每轮的轮密钥加变换的一种输入



#### 6.2.2 详细结构

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86.png)

**AES总体结构**

1. AES不是Feistel结构

AES算法没有使用Feistel结构，而是在每一轮都是用代替和混淆将整个数据分组作为一个单一的矩阵处理

2. 输入的密钥被扩展成44个32位字所组成的数组w[i],每轮由四个不同的字作为该轮的轮密钥
3. 由4个不同的阶段组成，包括一个置换和三个代替
   1. 字节代替 用一个S盒完成分组的字节到字节的代替
   2. 行位移 一个简单的置换
   3. 列混淆 利用域GF($2^8$)上的算术特性的一个代替
   4. 轮密钥加 当前分组和扩展密钥的一部分进行按位异或
4. 算法的机构非常简单，对加密和解密操作，算法由轮密钥加开始，接着进行9轮迭代运算，每轮都包含所有4个阶段的代替，接着是第10轮的三个阶段

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES%E4%B8%80%E8%BD%AE%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B.png)

5. 仅仅在轮密钥加阶段中使用密钥，因此，该算法由轮密钥加开始，以轮密钥加结束

> 如果将其他不需要密钥的运算用作算法的开始或结束，则在不知道密钥的情况下可以计算其逆，故不能增加算法的安全性

6. 轮密钥加实质上是一种Vernam密码形式，本身不难破译。其他三个阶段提供了混淆、扩散及非线性功能，这些阶段没有设计密钥，未提供算法的安全性

> 可以将该算法看做一个分组的异或加密（轮密钥加），接着对这个分组进行混淆，如此交替执行，这种方式非常安全有效

7. 每个阶段都是可逆的

> 字节代替，行位移和列混淆，在解密算法中用他们相对应的逆函数
>
> 轮密钥加的逆就是用同样的密钥和分组异或

8. 解密算法按逆序方式利用扩展密钥
9. 一旦将四个阶段求逆，可以证明解密函数的确可以恢复原来的明文

10. 加密和解密的最后一轮均只包含三个阶段



### 6.3 AES的变换函数

#### 6.3.1 字节代替函数

**正向和逆向变换**

字节代替的正向代替变换是一个简单的查表操作

AES定义了一个S盒，它是由16x16个字节组成的矩阵，包含了8位所能表示的256个数的一个置换

状态中每个字节按照如下方式映射位一个新的字节，把该字节的高4位作为行值，第4位作为列值，以这些行列值作为索引从S盒的对应位置去除元素作为输出

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES-%E5%AD%97%E8%8A%82%E4%BB%A3%E6%9B%BF%E5%8F%98%E6%8D%A2.png)

AES的S-盒如图所示

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES%E7%9A%84S%E7%9B%92.png)

假设输入为 10010101，即16进制数{95}，找到S盒第9行，第5列，对应的数值为{2A}



**s盒的构造**

1. **按字节值的升序初始化S盒**。第一行是{00},{01},{02},...,{0F},第二行为{10},{11},...,{1F}，以此类推
2. 把S盒中的每个字节映射为它的有限域$GF(2^8)$中的逆，{00}被映射为它自身{00}

> 补充内容：在有限域GF($2^8$)下计算乘法逆元
>
> $r_{-1}=a(x)=x^8+x^4+x^3+x+1$
>
> 计算{95}的乘法逆元
>
> $r_0=b(x)=x^7+x^4+x^2+1$
>
> 使用扩展欧几里得算法有
> $$
> r_1=r_{-1}(x)~mod~r_0(x)=x^5+x^4+1\\
> q_1=x\\
> v_1=x\\
> \\
> r_2=x\\
> q_2=x^2+x+1\\
> v_2=x^3+x^2+x+1\\
> \\
> r_3=x\\
> q_3=x^4+x^3\\
> v_3=x^6+x^3+1
> \\
> \\
> r_4=0\\
> q_4=x\\
> v_4=x^7+x^3+x
> $$
> 即{95}的逆元为{8A}

3. 把S盒中的每个字节的8个构成位记作($b_7,b_6,...,b_0$)。对S盒的每个字节的每个位作如下变换

$$
b_i'=b_i\oplus b_{(i+4)~mod~8}\oplus b_{(i+5)~mod~8}\oplus b_{(i+6)~mod~8}\oplus b_{(i+7)~mod~8}\oplus c_i
$$

其中$c_i$为{63}的字节c的第i位 c(01100011)

这个变换可以用矩阵描述

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES%20S%E7%9B%92%E6%9E%84%E9%80%A0%E5%8F%98%E6%8D%A2.png)

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/S%E7%9B%92y%E8%A1%8Cx%E5%88%97%E5%A4%84%E7%9A%84%E5%AD%97%E8%8A%82%E8%AE%A1%E7%AE%97.png)

逆字节变换使用到了逆S盒

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E9%80%86S%E7%9B%92.png)

逆S盒的构造方法,是利用S盒构造的变换的逆变换，然后再求乘法逆

逆变换为
$$
b_i'=b_{(i+2)~mod~8}\oplus b_{(i+5)~mod~8}\oplus b_{(i+7)~mod~8}\oplus d_i
$$
d={05}

**基本原理**

S盒被设计为能防止已有的各种密码分析攻击

具有良好的非线性度---使用了乘法逆

S盒中没有不动点，也没有反不动点---选择的常量c

S盒是可可逆的，但不是自逆的



#### 6.3.2 行位移变换

**正向和逆向变换**

状态的第一行保持不变、第二行循环左移一个字节，第三行循环左移两个字节，第四行循环左移三个字节

**基本原理**

这个转换确保了某列中的4字节被扩展到4个不同的列

![](image/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/AES%20%E8%A1%8C%E4%BD%8D%E7%A7%BB%E5%8F%98%E6%8D%A2.png)



#### 6.3.3 列混淆变换

![](image/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/AES%20%E8%A1%8C%E4%BD%8D%E7%A7%BB%E5%8F%98%E6%8D%A2.png)

**正向和逆向变换**

正 3123独立地进行操作，每列中的每个字节被映射为一个新值，这个值由该列中的四个字节通过函数变换得到

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%88%97%E6%B7%B7%E6%B7%86%E5%8F%98%E6%8D%A2-1.png)

这里的乘法和加法都是定义在GF($2^8$)上的

逆向列混淆变换由如下矩阵乘法定义:

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%88%97%E6%B7%B7%E6%B7%86%E5%8F%98%E6%8D%A2.png)

> 另一种列混淆方式---使用数学上的多项式表示
>
> 每列乘上一个固定的多项式a(x),然后模($x^4+1$)

**基本原理**

矩阵系数是基于码字间有最大举例的线性编码，使得在每列的所有字节有良好的混淆性

列混淆变换和行位移经过几轮变换后，所有的输出位均与所有的输入位相关



#### 6.3.4 轮密钥加变换

**正向和逆向变换**

在轮密钥加变换中，128位的状态按位与128位的轮密钥XOR

该操作剋看作是状态的一列中的四个字节与轮密钥的一个字进行列间的操作，我们也能将其视作字节级别的操作

逆向轮密钥加变换与正向轮密钥加变换一样，因为异或操作是其本身的逆



### 6.4 AES的密钥扩展

#### 6.4.1 密钥扩展算法

AES的密钥扩展算法的输入值是4个字，输入值是一个44个字组成(176字节)的一维线性数组

```cpp
KeyExpansion(byte ket[16],word w[44])
{
    word temp;
    for(i=0;i<4;i++) w[i]=(key[4*i],key[4*i+1],key[4*i+2],key[4*i+3]);
    for(i=4;i<44;i++){
        temp=w[i-1];
        if(i mod 4 =0) temp=SubWord(RotWord(temp)) XOR Rcon[i/4];
        w[i]=w[i-4] XOR temp
    }
}
```

输入密钥直接被赋值到扩展密钥数组的前4个字，然后每次用4个字填充扩展密钥数组余下的部分

在扩展密钥数组中，每一个新增的字w[i]的值依赖于w[i-1]和w[i-4]，对w数组下标位4的倍数的元素，使用了更复杂的函数(用字母g来表示)来计算

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES%E7%9A%84%E5%AF%86%E9%92%A5%E6%89%A9%E5%B1%95.png)

函数g由下述的子功能组成：

1. 子循环的功能是使一个字中的四个字节循环左移一个字节
2. 字代替利用S盒对输入字中的每个字节进行字节代替
3. 步骤一和步骤二的结果在与轮常量Rcon[j]相异或

轮常量是一个字，这个字左右边三个字节总为0

因此字与Rcon相异或，其结果只是与该字最左的那个字节异或

每轮的轮常量均不同，其定义为Rcon[j]=(Rc[j],0,0,0)，其中RC[1]=1,RC[j1]=2RC[j-1]\(这个乘法是定义在GF($2^8$)上的\)

#### 6.4.2 基本原理

密钥扩展算法用于防止已有的密码分析攻击

使用与轮相关的轮常量是为了防止不同轮的轮密钥产生方式上的对称性和相似性





### 6.5 一个AES的例子

> 参考教材p124~p128



### 6.6 AES的实现

#### 6.6.1 等价的逆算法

AES的解密算法和加密算法不同,尽管在加密和解密中密钥扩展的形式一样，但在解密中变换的顺序与加密中变换的顺序不同。

其缺点在于对同时需要加密和解密的应用而言，需要两个不同的软件或固件模块。  

解密算法的一个等价版本与加密算法有同样的结构,这个版本与加密算法的交换循序相同

在加密过程中，其轮结构为字节代替，行位移，列混淆，轮密钥加

在标准解密过程中，其轮结构为逆向行位移，逆向字节代替，轮密钥加，逆向列混淆

显然我们需要将前两个阶段交换，后两个阶段交换

**交换逆向行位移和逆向字节代替**

逆向移行影响在状态中字节的顺序，但并不更改字节的内容,同时也不依赖字节的内容来进行它的变换  

逆向字节代替影响状态中字节的内容，但不更改字节的顺序,同时也不依赖字节的顺序来进行它的变换  

因此，这两个操作可以交换

**交换轮密钥加和逆向列混淆**

轮密钥加和逆向列混淆并不更改状态中字节的顺序  

如果将密钥看成是字的序列，那么轮密钥加和逆向列混淆每次都对状态的一列进行操作，这两个操作对列输入是线性的，即对给定的状态$S_i$和给定的轮密钥$w_j$
$$
逆向列混淆(S_i\oplus w_j)=[逆向列混淆(S_i)]\oplus [逆向列混淆(w_j)]
$$


于是，我们可以得到一般解密算法的等价解密算法

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES%E7%AD%89%E4%BB%B7%E9%80%86%E5%AF%86%E7%A0%81.png)



#### 6.6.2 实现方面

**8位处理器**

AES能在8位处理器上非常有效地实现

轮密钥加是按字节异或操作

行位移式简单的移字节操作

字节代替是在字节级别上进行操作的，只要求一个256字节地表

列混淆变换是在域GF($2^8$)上的乘法，所有操作都是基于字节的，涉及简单的移位、条件异或或异或

如果不适用移位或条件异或操作，算法执行将更有效

利用性质{03}·x={02}·x$\oplus$x，能用如下的方式重写列混淆算法的方程集合

列混淆算法

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%88%97%E6%B7%B7%E6%B7%86%E7%AE%97%E6%B3%95.png)

重写为

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%88%97%E6%B7%B7%E6%B7%86%E7%AE%97%E6%B3%952.png)

乘以{02}包含一次一位和一次条件异或操作，这种实现方式容易遭受即使攻击，我们可以通过查表得方式代替乘法操作

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%88%97%E6%B7%B7%E6%B7%86%E7%AE%97%E6%B3%953.png)



**32位处理器**

对32位处理器，若将操作定义在32位的字上，就能执行更有效得操作

首先，使用代数形式定义一轮的四个变换

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES-%E4%BD%BF%E7%94%A8%E4%BB%A3%E6%95%B0%E5%BD%A2%E5%BC%8F%E8%A1%A8%E7%A4%BA%E4%B8%80%E8%BD%AE%E7%9A%84%E5%8F%98%E6%8D%A2.png)

在行位移等式中，列下标需要模四，我们能将所有这些表达式表达为一个等式

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AES-%E5%B0%86%E4%B8%80%E8%BD%AE%E7%9A%84%E5%8F%98%E6%8D%A2%E8%A1%A8%E8%BE%BE%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%AD%89%E5%BC%8F.png)

在第二个方程中，我们用向量的线性组合来表示矩阵的乘法,定义4个256字(1024字节)的表如下

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-15_14-53-07.png)

把每个表看作是输入一个字节值，产生一个列向量，该向量是对应该字节值的S盒输入的函数，这些表能被事先计算

我们用如下方式定义轮函数对一列的操作

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-15_14-54-14.png)

基于上述等式的实现仅需要四张表，每轮每列的四次异或以及存储这些表所需的4KB字节存储空间





## 第7章 分组加密的工作模式

### 7.1 多重加密和三重DES

#### 7.1.1 双重DES

两次加密使用两个密钥，给定明文P及密钥K1，K2 密文C按下述方式生成“
$$
C=E(K_2,E(K_1,P))
$$
解密时逆序使用这两个密钥
$$
P=D(K_1,D(K_2,C))
$$
对于DES，这种方法的密钥长度为56x2=112位，密码强度增强了



**约化为单次加密**

对于所有的56位密钥，给定K1,K2, 可能存在密钥K3使得


$$
E(K_2,E(K_1,O))=E(K_3,P)
$$
如果这个式子成立，则不管用DES进行多少次加密运算，都是没有用的

> 因为多次加密的效果在这个式子成立的条件下，与单次加密没有区别

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%8F%8C%E9%87%8D%E5%8A%A0%E5%AF%86.png)

DES加密是64位分组之间的映射，映射可以看作一个置换

对于$2^{64}$个可能的明文分组，DES用某特定密钥加密后都唯一对应一个64位的密文分组,$2^{64}$个可能的输入，有$2^{64}!$个一对一映射，DES为每个密钥定义了一个映射，映射总数为$2^{56}$ 

完全有理由认为，双重DES所对应的映射不能为单DES所定义

> 这个假设在1992年被证明



**中间相遇攻击**

中间相遇攻击不依赖于DES的任何特殊性质，对所有分组密码都有效

算法描述：

假设
$$
C=E(K_2,E(K_1,P))
$$
则有
$$
X=E(K_1,P)=D(K_2,C)
$$
给定明密文对(P,C),攻击如下展开

1. 将P按所有可能的密钥K1加密，得到的$2^{56}$个结果按X的值顺序放在一个表内
2. 将C用所有可能的密钥K2解密，每解密一次就将解密结果与表中的值比较，如果有相等的，就用刚才测试的两个密钥对一个新的明密对进行验证，如果两个密钥都产生了正确的密文，则认定这两个密钥是正确的密钥

复杂度分析：

对于给定明文x，以二重DES加密将有$2^{64}$个可能的密文，而可能的密钥数$2^{112}$个。所以，在给定明文下，将有$\frac{2^{112}}{2^{64}}=2^{48}$个密钥能产生给定的密文

用另一对64比特明文/密文进行检验，就使虚报率$2^{48-64}=2^{-16}$,这样的虚报率是可以忽略的



该攻击算法需要空间为$2^{56}\times 8Byte$ 最大实验的加密次数为2x$2^{56}$ 比攻击单DES所需的$2^{55}$数量级差不了多少



#### 7.1.2 使用两个密钥的三重DES

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%B8%89%E9%87%8D%E5%8A%A0%E5%AF%86.png)

为了对付中间相遇攻击，我们很容易想到一种方法：使用三个不同的密钥进行三次加密

这样，已知明文攻击的代价将升级为$2^{112}$数量级，显然是不可行的，并且，他需要168位密钥，使用起来非常笨拙

使用两个密钥进行三次加密，是一个更好的方案

具体的运算过程是：加密-解密-加密(EDE)
$$
C=E(K1,D(K2,E(K_1,P)))
$$

$$
P=D(K_1,E(K_2,D(K_1,C)))
$$

第二步使用解密操作并没有什么密码学上的深层含义，这仅是为了三重DES的用户可以利用该算法解密单DES加密的数据

使用两个密钥的三重DES已经广泛代替了DES，并已用于密钥管理标准ANSI X9.17和ISO8723

对3DES的穷举攻击的代价是$2^{112}$数据集的，且估计用差分密码分析的代价



目前，还没有对3DES的可行的攻击方法，下面介绍几种攻击方法

1. 挨个查看可能的明文，看哪一个明文的第一个中间值A=0，然后用中间相遇攻击来得到两个密钥，这种攻击方法的代价是$2^{56}$数量级的，但是它需要$2^{56}$个选择明密文对，这是不可能的

2. 若已知A和C，那么问题相当于对双重DES的攻击，但是，只要不知道密钥，即使知道了P和C，攻击者还是得不到A，然而，攻击者可以选择A的一个可能值，再试着找出一个可产生A的已知(P,C)对，具体攻击过程如下所述:

获取n个(P,C)对，将这些已知(P,C)对按P排序放在表中

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-17_17-01-11.png)

为A任意选择值a，创建第2张表，表的项按下列方式定义。对每个可能的密钥K1=i，计算可产生a的明文值$P_i$
$$
P_i=D(i,a)
$$
![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-17_17-03-57.png)

现在表2中有了一批K1的候选值，现在需要搜索K2，对任意可能的$2^{56}$个K2=j,对选定的a计算第二个中间值
$$
B_j=D(j,a)
$$
每做一步就在表2中查找Bj，如有相等者，则表2里的相应密钥i和j旧址未知密钥(K1,K2)的可能值

对于这样的密钥对，再进行几个其他的(P,C)对的测试，要是测试出来用某些P按密钥(i.j)不能产生C，则重新选择一个新的a，否则,(i,j)就是密钥

对给定的(P,C)，选择a成功的可能性为$2^{-64}$，给定n个(P,C)对，单个选择a成功的可能性为$\frac{n}{2^{64}}$

尝试a的个数为
$$
\frac{2^{64}}{n+1}
$$
则攻击的期望运算时间是以下数量级的
$$
(2^{56})\frac{2^{64}}{n}=2^{120-log_2n}
$$


#### 7.1.3 使用三个密钥的三重DES

很多人觉得采用三个密钥的三重DES算法才是最好的方案，三重DES的密钥长度为168位，定义为
$$
C=E(K_3,D(K_2,E(K_1,P)))
$$


### 7.2 电码本模式

分组密码的输入为具有b位固定长度的明文分组和密钥，输出位b位的密文

若明文长度大于b位，则可简单将其分成b位一组的块，如果简单地每次使用相同地密钥对多个分组加密，会引发很多安全问题

因此，为了分组密码应用到各种各样地实际应用，NIST定义了五种"工作模式"

> 工作模式，本质上是一项增强密码算法或者使密码算法适应具体应用的技术

本节介绍最简单的模式：**电码本(ECB)模式**，它一次处理一组明文分块，每次使用相同的密钥加密



ECB模式中，若明文长于b位，则将明文分为b位一组的块，必要时对最后一块进行填充。解密时也是一次执行一块，且使用相同的密钥

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-17_17-35-30.png)

ECB模式的

ECB模式特别适合于数据较少的情况，比如加密密钥，因此，想要安全传输一个DES或AES密钥，选择这种模式是合适的



**ECB模式的缺点**

对于很长的消息，ECB模型可能不安全

若一段消息中，有几个相同的明文组，那么密文也将出现几个相同的密文分组

若消息是非结构化的，密码分析者可以利用规律性特征来破译



**更复杂的工作模式的评估和实施:**

总体比较：与ECB模式加解密相比，加密和解密所需的额外操作

错误传播：第i个密文分组的错误会只被模式同步后的一些明文分组继承

错误传播：第i个密文分组的错误会被第i组及后所有明文分组继承，这意味着一位错误发生在密文分组传输的过程而不是明文分组加密的计算错误

扩散：熵值较小的密文分组不应该被映射到密文分组(熵值较小的密文分组等同于可预测性或者缺乏随机性)

安全性： 密文分组是否会泄露关于明文分组的信息



### 7.3 密文分组链接模式

为了克服ECB的这些弱点，需要将重复的明文分组加密成不同的密文分组

**密文分组链接模式CBC**是满足这一要求的简单方法

这种模式下，加密算法的输入是当前的明文分组和上一个密文组的异或，而使用的密钥是相同的

这相当于将所有的明文都链接起来了

加密算法的每次输入与本明文组没有固定的关系，如果有重复的明文分组，加密后看不出来

与ECB方式类似，CBC方式也要求最后的分组不是完整的分组,则需要填充至b位的满分组

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-17_19-27-47.png)

解密时，每个密文分组分别解密，再与上一个密文异或就可恢复出明文

特别地，第一块明文需要与一个初始向量(IV)异或后再加密，解密时第一块密文解密的结果与IV异或而恢复出第一块明文

**CBC模式可以定义如下**

**解密：**
$$
C_1=E(K,[P_1\oplus IV])\\
C_j=E(K,[P_j\oplus C_{j-1}])~~j=2,...,N
$$


**加密:**
$$
P_1=D(K,C_1)\oplus IV\\
P_j=D(K,C_j)\oplus C_{j-1}~~j=2,...,N
$$
IV必须为收发双方共享，但第三方不能预测，为了最大程度的安全，IV不能不经授权而修改(可以对IV先用ECB加密在发送)



**优点**

CBC的链接机制使得它适合于加密长度大于b位的消息

CBC不仅可以用于加密，还可以用于认证



### 7.4 密文反馈模式

对于AES,DES或任何的分组密码，加密是对一个b位分组进行加密

但是本节讨论的**密文反馈模式(Cipher Feedback,CFB)**，可以将分组密码当作流密码使用，流密码的密文和明文等长，传输能力更强(不需要传输额外的信息)

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-18_08-59-19.png)

上图描述了CFB模式，假设传输单元是s 位，s通常为 8。同使用 CBC 模式一样，明文的各个单元要链接起来，所以任意个明文单元的密文都是前面所有明文的函数  

**加密**

加密函数的输入是b位的移位寄存器，它的值为初始向量IV。加密函数输出最左边的 s 位与明文的第一个分段$P_1$异或得到密文的第一个单元$C_1$然后将$C_1$发送出去.

然后，移位寄存器左移s位，$C_1填入移位寄存器的最右边s位$，知道所有明文单元被加密完

**解密**

解密使用相同的方法，不同点是，将收到的密文单元与加密函数的输出异或得到明文单元

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-18_09-12-14.png)

### 7.5 输出反馈模式

**输出反馈模式(Output Feedback,OFB)**的结构与CFB很相似

它使用加密函数的输出填充移位寄存器，且对整个明文和密文分组进行运算，而不是仅对s位的子集进行运算

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-18_09-28-43.png)

**加密**
$$
C_j=P_j\oplus E(K,O_{j-1})
$$
其中
$$
O_{j-1}=E(K,O_{j-2})
$$
加密表达式可以写成如下的形式
$$
C_j=P_j\oplus E(K,[C_{j-1}\oplus O_{j-1}])
$$
解密可表示如下
$$
P_j=C_j\oplus E(K,[C_{j-1}\oplus P_{j-1}])
$$
如果分组长度为b，如果明文的最后一个分组包含u位，u<b，那么最后输出的分组$O_N$的最左边的u位用来做异或运算，最后的输出分组的其余b-u位丢弃不用



OFB模式的初始向量IV必须是一个时变值，即IV对每次加密运算都是唯一的

> 加密输出的分组构成的序列$O_i$仅仅依赖密钥和IV,而不依赖明文
>
> 于是，给定密钥和IV，用于和明文流进行异或运算的输出位流是固定的，如果两个不同的消息在同一个地方有一个相同的明文分组，那么攻击者能够判断出那部分的$O_i$输出流

OFB的一个优点是在传输过程中，在某位上发生的错误不会影响到其他位

OFB的缺点是，抗消息流篡改攻击能力不如CFB



### 7.6 计数器模式

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-18_10-19-23.png)

计数器使用与明文分组规模相同的长度，加密不同的明文组的计数器的值必须是不同的

典型的，计数器首先被初始化位某一值，然后署消息块的增加计数器的值加1(模 $2^b$，b为分组长度)

我们可以如下定义CTR模式

**加密**
$$
C_j=P_j\oplus E(K,T_j)~~j=1,...,N-1 \\
C_N^*=P_N^* \oplus MSB_u[E(K,T_N)]
$$

$$

$$

**解密**
$$
P_j=C_j\oplus E(K,T_j)~~j=1,...,N-1\\
P_N^*=C_N^* \oplus MSB_u[E(K,T_N)]
$$
初始计数器的值必须为变值

优点：

1. 硬件效率 CTR模型能够并行处理多块明文(密文)的加密(解密) CTR模型中，吞吐量仅受可并行度的限制
2. 软件效率 CTR模式能够进行并行计算，可以充分利用能够支持如下并行特征的各类处理器，入提供流水线、每个时钟周期的多指令分派，大量的寄存器和SIMD指令等并行特征
3. 预处理 基本加密算法的执行并不依赖于明文或密文的输出，如果有足够的存储器可用并能提供安全，可以预处理加密盒的输出，这个输出右进一步作为XOR函数的输入

4. 随机访问 明文或密文的第i个分组能够用一种随机访问的方式处理
5. 可证明安全性 CTR模式至少和本节讨论的其他模式一样安全
6. 简单性 CTR只要求实现加密算法，并不要求实现解密算法



 除了ECB模式外，NIST批准的所有分组密码工作模式都含有反馈

OFB和CTR模式的输出独立于明文和密文，是流密码的自然候选算法，通过XOR运算每次加密一个明文分组

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Snipaste_2024-10-18_11-29-52.png)
